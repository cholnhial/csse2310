#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <stdbool.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>

#include "utils.h"
#include "common.h"

/* The default file to read words from when user hasn't specified a file name */
#define DEFAULT_DICTIONARY_FILENAME "/usr/share/dict/words"

/* We dynammically resize the word read, we allocate in chunks for speed*/
#define READ_MEM_ALLOCATION_CHUNK 32

/* Enum representing program search type */
typedef enum {
    SEARCH_PREFIX, SEARCH_EXACT, SEARCH_ANYWHERE, BAD_OPTION, SORT_OPTION
} OptionType;

/* A structure that represents the program options */
typedef struct {
    OptionType search_type;
    bool sort;
    char *pattern;
    char *dictionary_filename;
} Options;

/**
 * Prints the program usage and exits with a specified error code.
 *
 * Params:
 *  stream - The file stream to output the usage message to
 *  exit_code - The exit code which to exit with and terminate execution
 *
 *  Returns: nothing
 */
void print_usage(FILE *stream, int exit_code) {
    fprintf(stream, "Usage: search [-exact|-prefix|-anywhere] [-sort] pattern [filename]\n");
    exit(exit_code);
}

/**
 * Checks whether a command-line argument is an options.
 *
 * Parameters:
 *  argument - The argument string to check if it starts with "-"
 *
 *  Returns: true if it's an option, false otherwise.
 */
bool is_argument_an_option(char* argument) {
    if (strstr(argument, "-") != NULL) {
        return true;
    }

    return false;
}

/**
 * Maps a command-line option to its type.
 *
 * BAD_OPTION is returned if it's an option not expected.
 *
 * Parameters:
 *  option - The command line argument to check
 *
 *  Returns an OptionType enum
 *
 * */
OptionType get_option_type(char* option) {

    if (!strcmp(option, "-exact")) {
        return SEARCH_EXACT;         
    } else if (!strcmp(option, "-prefix")) {
        return SEARCH_PREFIX;
    } else if (!strcmp(option, "-anywhere")) {
        return SEARCH_ANYWHERE;
    } else if(!strcmp(option, "-sort")) {
        return SORT_OPTION; 
    } else {
        return BAD_OPTION;
    }
}

/**
 * Constructs an options struct that represents the command-line options passed.
 *
 * Paramaters:
 * argc - The total number of arguments passed to the program
 * argv - The list of arguments
 *
 * Returns NULL or a valid Options structure
 **/
Options* parse_options(int argc, char **argv) {

    if ((argc - 1) < 1) {
        return NULL; 
    }

    Options *options = (Options*) malloc(sizeof(Options)); 
    memset(options, 0, sizeof(Options));
    bool search_exact_found = false;
    bool search_prefix_found = false;
    bool search_anywhere_found = false;
    bool is_sort_specified = false;
    int pattern_index = -1;
    int filename_index = -1;
    int non_option_arguments_found = 0;

    /* Process command-line options*/
    for(int i = 1; i < argc; i++) {

        /* Is argument an option */
        if (is_argument_an_option(argv[i])) {

            OptionType search_type = get_option_type(argv[i]);

            switch (search_type) {

                case SEARCH_EXACT:
                    if (!search_exact_found) {
                        search_exact_found = true;
                    } else {
                        print_usage(stderr, EXIT_FAILURE);
                    }
                    break;
                case SEARCH_PREFIX:
                    if (!search_prefix_found) {
                        search_prefix_found = true;
                    } else {
                        print_usage(stderr, EXIT_FAILURE);
                    }
                    break;
                case SEARCH_ANYWHERE:
                    if (!search_anywhere_found) {
                        search_anywhere_found = true;
                    } else {
                        print_usage(stderr, EXIT_FAILURE);
                    } 
                    break;
                case SORT_OPTION:
                    if (!is_sort_specified) {
                        is_sort_specified = true;
                    } else {
                        print_usage(stderr, EXIT_FAILURE);
                    }

                    break;
                default:
                    print_usage(stderr, EXIT_FAILURE);

            }


        } else {
            non_option_arguments_found++;

            /*This is either a pattern or a file */
            if (pattern_index == -1) {
                pattern_index = i;
            }

            /* After a pattern we expect a file*/
            if (pattern_index != -1 && filename_index == -1 && pattern_index != i) {
                filename_index = i;
            }
        }
    }

    if (non_option_arguments_found > 2 || pattern_index == -1) {
        print_usage(stderr, EXIT_FAILURE);
    }

    if (search_exact_found && !(search_prefix_found || search_anywhere_found)) {
        options->search_type = SEARCH_EXACT;

    } else if (search_prefix_found && 
            !(search_exact_found || search_anywhere_found)) {
        options->search_type  = SEARCH_PREFIX;
    } else if (search_anywhere_found &&
            !(search_exact_found || search_prefix_found)) {
        options->search_type = SEARCH_ANYWHERE;
    } else {
        options->search_type = SEARCH_EXACT;
    }

    options->sort = is_sort_specified;

    if (pattern_index != -1) {
        options->pattern = argv[pattern_index];
    } 

    if (filename_index != -1) {
        options->dictionary_filename = argv[filename_index];
    } else {
        options->dictionary_filename = DEFAULT_DICTIONARY_FILENAME;
    }

    return options;
}


/**
 * Validates the pattern the user specified.
 * 
 * Parameters:
 * pattern - the pattern to validate
 *
 * Return true if invalid, false otherwise
 *
 * */
bool is_valid_pattern(char* pattern) {
    for (int i = 0; i < strlen(pattern); i++) {
        if (pattern[i] != '?' && !isalpha(pattern[i])) {
                return false;
        }
    }

    return true;
}

/**
 * 
 * Checks whether the file exists or can be read.
 * Exits with an error code indicating failure.
 *
 * Returns nothing
 *
 * */
void exit_on_incorrect_file_access(char* filename) {

    /* Check if file exists and if we can read */
    int ret = access(filename, F_OK | R_OK);

    if (ret == -1) {
        fprintf(stderr, "search: file \"%s\" can not be opened\n", filename);
        exit(EXIT_FAILURE);
    }
}

/**
 * Checks whether a pattern is to match prefix "????...?" 
 *  
 *  Parameters:
 *   pattern - THe pattern to check if it's a match all prefix
 *
 * Returns true if this is a match any prfix, false otherwise
 * */
bool is_match_all_prefix(char *pattern) {
    for(int i = 0; i < strlen(pattern); i++) {
        if (pattern[i] != '?') {
            return false;
        }
    }

    return true;
}

/**
 *  Checks whether a word is all alphabetic
 *
 *  Parameters:
 *      word - The word to check if it's all alphabetic
 *
 *  Returns true if the word is alphabetic false otherwise
 * */
bool is_all_alphabetic_word(char *word) {
    for(int i = 0; i < strlen(word); i++) {
        if (!isalpha(word[i])) {
            return false;
        }
    }

    return true;
}

/**
 *
 *  This function is responsible for handling prefix matches
 *
 *  Parameters:
 *      word - The word to check if it matches a prefix
 *      pattern - The pattern containing the prefix
 *
 *  Returns true if the pattern matches, false otherwise 
 **/
bool is_word_a_prefix_match(char *word, char *pattern) {

    if (strlen(word) >= strlen(pattern) && is_all_alphabetic_word(word)) {

        if (is_match_all_prefix(pattern)) {
            return true;
        }

        for (int i = 0; i < strlen(pattern); i++) {
            if(!isalpha(word[i])) {
                return false;    
            }

            if (pattern[i] == '?') {
                continue;
            }

            if (isalpha(word[i]) && tolower(pattern[i]) == tolower(word[i])) {
                continue;
            } else {
                return false;
            }          
        }

        return true;
    }

    return false;
}

/**
 * Goes through the dictionary to check all words that match the prefix
 *
 * Parameters:
 *  pattern - The pattern that contains the prefix
 *  dict - The dictionary containing all the words to check against
 *
 *  Returns a dictionary containing the list that contains the matched words 
 *
 * */
DictionaryWords *pattern_match_words_prefix(char* pattern, DictionaryWords *dict) {
    DictionaryWords* matches_dict = dict_words_init();

    for(int i = 0; i < dict->size; i++) {
        if (is_word_a_prefix_match(dict->words[i], pattern)) {
            dict_words_add(matches_dict, dict->words[i]); 
        }
    }

    return matches_dict;
}

/**
* Check whether two letters match. Will return true if letter is being
* compared with '?'
*  
*  Parameters:
*   pattern_letter   - the letter of the pattern to compare
*   word_letter      - the letter in the word to compare 
*   
* Returns true if they match or is a comparison again '?', false otherwise
*/
bool is_letter_a_match(char pattern_letter, char word_letter) {

    if (pattern_letter == '?') {
        return true;
    }

    if (isalpha(word_letter) && tolower(pattern_letter) == tolower(word_letter)) {
        return true;

    }

    return false;
}

/**
 * Find the next beginning of the word that matches
 * the first letter of the pattern.
 *
 * Parameters:
 *  patern - The pattern
 *  word - The word we will search for the beginning of the pattern
 *  last_index - Where we will start looking for the start in the word
 *
 * Returns the index to where the word starts, -1 if none can be found
 */
int get_start_of_next_match_index(char *pattern, char *word, int last_index) {

    bool last_letter_matched = false;

    /*Seek for first letter that matches*/
    int i = last_index;
    while(i < strlen(word)) {
        last_letter_matched = is_letter_a_match(pattern[0], word[i]); 
        if(last_letter_matched && tolower(pattern[0]) !=  tolower(word[i+1])) {
            break;
        }
        i++;
    }

    return last_letter_matched ? i : -1;
}


/**
 * This is the algorithm to try and match parts of a word 
 * with the anywhere search strategy. It First tried
 * to locate an index in the word where the first character matches
 * the first character of the pattern. It will keep doing this until
 * all the places starting with the first letter of the pattern are exhausted.
 *
 * Parameter:
 *  word - The word to search for the pattern
 *  pattern - The pattern to search the word by
 *
 *
 */
bool is_word_an_anywhere_match(char *word, char *pattern) {

    /* if word length is less than the pattern or word is not alphabetic,
     * no match is found */
    if(strlen(word) < strlen(pattern) || !is_all_alphabetic_word(word)) {
        return false;
    }

    int start_of_match_index = 0;
    int match_count = 0;   
    while((start_of_match_index = get_start_of_next_match_index(pattern,
                    word, start_of_match_index)) != -1) {

        bool last_letter_matched = start_of_match_index != -1;
        match_count = 0;
        int  i = start_of_match_index;
        if(start_of_match_index != -1) {
            int j = 0;
            do {
                bool is_new_letter_a_match = is_letter_a_match(pattern[j], word[i]);
                if (is_new_letter_a_match) {
                    match_count++;
                }
                if (last_letter_matched && !is_new_letter_a_match) {
                    last_letter_matched = false;
                    break;
                }
                last_letter_matched = is_new_letter_a_match;

                j++;
                i++;
            } while(i < strlen(word) && j < strlen(pattern));
           
            start_of_match_index = i;
            
            if  (match_count == strlen(pattern)) {
                break;
            }

        }
           
    }


    return match_count == strlen(pattern) ? true : false;
}

/**
 * Searches word for a match of pattern anywhere in the word.
 * Will return a valid list containg matched words.
 *
 * Parameters:
 *  pattern - The pattern to look for
 *  dict - The dictionary containing the words
 *
 *  Returns a dictionary with all the matched words, which may be blank
 */
DictionaryWords *pattern_match_words_anywhere(char* pattern, DictionaryWords *dict) {
    DictionaryWords* matches_dict = dict_words_init();

    for(int i = 0; i < dict->size; i++) {
        if (is_word_an_anywhere_match(dict->words[i], pattern)) {
            dict_words_add(matches_dict, dict->words[i]); 
        }
    }

    return matches_dict;
}

/**
 *
 *  Checks if the word matches an exact pattern search type
 *
 *  Parameters:
 *      word - the word to check against the patter
 *      pattern - the pattern to do an exact match with
 *
 *  Returns true if the word matches, false otherwise
 *  */
bool is_word_an_exact_match(char *word, char *pattern) {

    if(strlen(word) != strlen(pattern)) {
        return false;
    }

    for (int i = 0; i < strlen(word); i++) {
        if(!isalpha(word[i])) {
            return false;    
        }
        if (pattern[i] == '?') {
            continue;
        }

        if (isalpha(word[i]) && tolower(pattern[i]) == tolower(word[i])) {
            continue;
        } else {
            return false;
        }
    }

    return true;
}

/**
 *  Searches for words that match using the exact search type.
 *  It builds a dynamic list with all the words and returns it.
 *
 *  Parameters:
 *      pattern - the pattern to match the words against
 *      dict - the dictionary of words to search 
 *
 *  Returns a dictionary containing the list of words, might be empty, check dict->size. 
 *  
 * */
DictionaryWords* pattern_match_words_exact(char* pattern, DictionaryWords* dict) {
    DictionaryWords* matches_dict = dict_words_init();

    for (int i = 0; i < dict->size; i++) {

        /* We only want words that the same length */
        if (strlen(dict->words[i]) == strlen(pattern)) {
            if (is_word_an_exact_match(dict->words[i], pattern)) {
                dict_words_add(matches_dict, dict->words[i]);        
            }
        }
    }

    return matches_dict;
}

/**
 *
 *  Reads all the words from a file and puts them into the structure.
 *  The structure has the words and how many there is for easy iteration.
 *  
 *  Paramaters:
 *   filename - The file to read the words from
 *
 *   Returns the dictionary words 
 *
 * */
DictionaryWords *read_words_from_file(char* filename) {

    FILE* file = fopen(filename, "r");

    DictionaryWords* dict = dict_words_init();

    char* word;
    while((word = read_line(file, READ_MEM_ALLOCATION_CHUNK))) {
        dict_words_add(dict, word);
    }
    return dict;
}

int main(int argc, char **argv) {

    Options *options = parse_options(argc, argv);
    if (!options) {
        print_usage(stderr, EXIT_FAILURE);
    } else {
        if (options->dictionary_filename) {
            exit_on_incorrect_file_access(options->dictionary_filename);
        }

        if (!is_valid_pattern(options->pattern)) {
            fprintf(stderr, "search: pattern should only contain question marks and letters\n");
            exit(EXIT_FAILURE);
        }

        DictionaryWords* dict = read_words_from_file(options->dictionary_filename);
        DictionaryWords* matches; 
        switch(options->search_type) {
            case SEARCH_PREFIX:
                matches = pattern_match_words_prefix(options->pattern, dict);
                break;
            case SEARCH_ANYWHERE:
                matches = pattern_match_words_anywhere(options->pattern, dict);
                break;
            default:
                matches = pattern_match_words_exact(options->pattern, dict);
        }

        if (options->sort) {
            qsort(matches->words, matches->size ,sizeof(char*), compare_words);
        }

        for (int i = 0; i < matches->size; i++) {
            printf("%s\n", matches->words[i]);
        }
    }

    return EXIT_SUCCESS;
}
